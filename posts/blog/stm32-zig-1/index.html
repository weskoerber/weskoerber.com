<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         STM32 'Hello, world!' with Zig
        
    </title><meta content="STM32 'Hello, world!' with Zig" property=og:title><link href=https://www.weskoerber.com/fonts.css rel=stylesheet><script async data-goatcounter=https://weskoerber.goatcounter.com/count src=https://www.weskoerber.com/js/count.js></script><noscript><img src="https://weskoerber.goatcounter.com//count?p=/posts/blog/stm32-zig-1/&t=STM32 'Hello, world!' with Zig"></noscript><script src=https://www.weskoerber.com/js/toc.js></script><link title="Wes Koerber" href=https://www.weskoerber.com/atom.xml rel=alternate type=application/atom+xml><link href=https://www.weskoerber.com/theme/light.css rel=stylesheet><link href=https://www.weskoerber.com/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://www.weskoerber.com/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://www.weskoerber.com/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://www.weskoerber.com>Wes Koerber</a><div class=socials><a class=social href=https://github.com/weskoerber rel=me> <img alt=github src=https://www.weskoerber.com/social_icons/github.svg> </a><a class=social href=https://gitlab.com/weskoerber rel=me> <img alt=gitlab src=https://www.weskoerber.com/social_icons/gitlab.svg> </a><a class=social href=https://www.linkedin.com/in/weskoerber/ rel=me> <img alt=linkedin src=https://www.weskoerber.com/social_icons/linkedin.svg> </a><a class=social href=mailto:wes@weskoerber.com rel=me> <img alt=email src=https://www.weskoerber.com/social_icons/email.svg> </a><a class=social href=https://www.weskoerber.com/atom.xml rel=me> <img alt=rss src=https://www.weskoerber.com/social_icons/rss.svg> </a></div></div><nav><a href=https://www.weskoerber.com/posts style=margin-left:.5em>/posts</a><a href=https://www.weskoerber.com/about style=margin-left:.5em>/about</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://www.weskoerber.com/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://www.weskoerber.com/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>STM32 'Hello, world!' with Zig<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-09-23</time></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#introduction>Introduction</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#goals>Goals</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#what-we-re-working-with>What we're working with</a> <ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#hardware>Hardware</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#software>Software</a></li><ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#flash-programming>Flash programming</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#compiler-and-binary-utilities>Compiler and binary utilities</a></ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#literature>Literature</a></ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#getting-started>Getting started</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#build-my-thing>Build my thing</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#convert-elf-to-binary>Convert ELF to binary</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#memory-map-and-linking>Memory map and linking</a> <ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#linker-script>Linker script</a></li><ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#memory-regions>Memory Regions</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#entry-point>Entry point</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#sections>Sections</a></ul></ul><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#vector-table>The vector table</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#cortex-m4-startup>Cortex-M4 startup</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#before-main>What happens before main()?</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#flashing>Flashing</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#blink-a-damn-led>Blink a damn LED</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#hello-world>Hello, world!</a><li><a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#conclusion>Conclusion</a></ul></div><section class=body><h1 id=introduction>Introduction</h1><p>I've been using Zig <a href="https://github.com/weskoerber?tab=repositories&q=&type=&language=zig&sort=stargazers">a lot</a> over the past few months writing wide variety of projects. From <a href=https://github.com/weskoerber/kewpie>kewpie</a>, a simple query string parser, to <a href=https://github.com/weskoerber/dirtstache>dirtstache</a>, a <a href=https://mustache.github.io/>Mustache</a> implementation -- even a <a href=https://curl.se/libcurl/>libcurl</a> wrapper with <a href=https://github.com/weskoerber/zig-curl>zig-curl</a> -- I have experience with Zig across a wide range of domains.<p>However, I've always wanted to use Zig on an embedded target. On paper, Zig is an excellent choice for embedded programming: no implicit allocations, no hidden control flow, seamless integration with the C ABI, a fantastic build system<sup class=footnote-reference><a href=#1>1</a></sup>, etc. However, that's on paper. I wanted to see for myself if the advertised strengths of Zig held up when put to the test, especially in a resource-constrained embedded environment.<p>Well, I did just that. In this post I'll retrace my steps in how I went from an empty <code>main.zig</code> to printing <code>Hello, World!</code> to my terminal.<h1 id=goals>Goals</h1><p>Before writing any Zig code, I set some goals for this project in order to maximize my learning potential:<ol><li>No dependencies<li>100% Zig code<li>A 3-day time limit</ol><h1 id=what-we-re-working-with>What we're working with</h1><h2 id=hardware>Hardware</h2><p>I have a few Cortex-M4 development boards laying around: an <a href=https://docs.rs-online.com/3934/A700000006811369.pdf>MSP432P4</a> (<a href=https://e2e.ti.com/support/microcontrollers/arm-based-microcontrollers-group/arm-based-microcontrollers/f/arm-based-microcontrollers-forum/1007640/msp432p401r-is-the-msp432-line-discontinued>RIP</a>), a <a href=https://www.st.com/en/evaluation-tools/nucleo-f401re.html>NUCLEO-F4</a>, and a <a href=https://www.st.com/en/evaluation-tools/nucleo-l496zg.html>NUCLEO-L4</a>. For this experiment, I decided to go with the NUCLEO-F4 for no reason other than it was sitting closest to me at the time.<p>The process is quite similar for other Cortex-M4-based MCUs, so feel free to follow along with your own hardware. The peripherals on your device may vary, so consult your device's reference manual.<h2 id=software>Software</h2><h3 id=flash-programming>Flash programming</h3><p>You'll need a way to flash the code to your MCU. I'm using <a href=https://openocd.org/>OpenOCD</a> to flash mine. However, there are several other utilities out there you may choose from.<h3 id=compiler-and-binary-utilities>Compiler and binary utilities</h3><p>I'm using Zig master version <code>0.14.0-dev.1632+d83a3f174</code>, installed via <a href=https://github.com/weskoerber/zvm>zvm</a>. Note that this version is in development and has some <a href="https://github.com/ziglang/zig/issues?q=is%3Aissue+is%3Aopen+milestone%3A0.14.0+label%3Abreaking">planned breaking changes</a>, so this may not work in the future.<p>In addition to the Zig compiler (and its suite of binary utilities), the <a href=https://www.gnu.org/software/binutils/>GNU binutils</a> will help us out immensely if things go wrong. Notably, Zig doesn't ship with <a href=https://sourceware.org/binutils/docs-2.39/binutils/nm.html><code>nm</code></a> or <a href=https://sourceware.org/binutils/docs-2.39/binutils/objdump.html><code>objdump</code></a> utilities. I strongly recommend installing the <a href=https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain>GCC toolchain for ARM</a> before continuing.<h2 id=literature>Literature</h2><p>You'll absolutely need the documentation on your MCU, unless you're some superhuman that's memorized everything. At the very least, you'll need:<ul><li>MCU reference manual<li>Cortex-M4 reference manual<li>Device-specific datasheet<li>Development board user manual</ul><h1 id=getting-started>Getting started</h1><p>I was excited. I finally sat down and was ready to make some LEDs blink. I created my project and an empty <code>build.zig</code> and <code>main.zig</code> with an empty while loop:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>build</span><span>(</span><span style=color:#fdf4c1>b</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>std.Build</span><span>) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span>
</span><span style=color:#fa5c4b>const</span><span> std </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"std"</span><span>);
</span></code></pre><p><code>main.zig</code>:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>asm volatile </span><span>(</span><span style=color:#b8bb26>"nop"</span><span>); </span><span style=color:#928374;font-style:italic>// Prevents optimizing the loop away
</span><span>}
</span></code></pre><h1 id=build-my-thing>Build my thing</h1><p>The first logical step here was to get <em>something</em> to build. Since we know we're only going to run this code on a Cortex-M4 MCU, we can hard-code the target field using <a href=https://ziglang.org/documentation/master/std/#std.Build.resolveTargetQuery><code>b.resolveTargetQuery</code></a> instead of using the usual <a href=https://ziglang.org/documentation/master/std/#std.Build.standardTargetOptions><code>b.standardTargetOptions</code></a>.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>build</span><span>(</span><span style=color:#fdf4c1>b</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>std.Build</span><span>) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const</span><span> exe </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addExecutable</span><span>(.{
</span><span>        .name </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"stm32-test"</span><span>,
</span><span>        .root_source_file </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>path</span><span>(</span><span style=color:#b8bb26>"src/main.zig"</span><span>),
</span><span>        .optimize </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>standardOptimizeOption</span><span>(.{}),
</span><span>        .target </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>resolveTargetQuery</span><span>(.{
</span><span>            .cpu_arch </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .thumb</span><span>,
</span><span>            .cpu_model </span><span style=color:#fe8019>=</span><span> .{ .explicit </span><span style=color:#fe8019>= &</span><span>std.Target.arm.cpu.cortex_m4 },
</span><span>            .os_tag </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .freestanding</span><span>,
</span><span>            .abi </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .eabihf</span><span>,
</span><span>        }),
</span><span>    });
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> install_exe </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addInstallArtifact</span><span>(exe, .{});
</span><span>
</span><span>    b.</span><span style=color:#fdf4c1>getInstallStep</span><span>().</span><span style=color:#fdf4c1>dependOn</span><span>(</span><span style=color:#fe8019>&</span><span>install_exe.step);
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>const</span><span> std </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"std"</span><span>);
</span></code></pre><p>After running <code>zig build</code>, <code>stm32-test</code> was put in <code>zig-out/bin</code>:<pre style=color:#fdf4c1aa;background-color:#282828><code><span>❯ file zig-out/bin/stm32-test
</span><span>zig-out/bin/stm32-test: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, with debug_info, not stripped
</span></code></pre><p>Theoretically, we could flash this to the MCU right now, but it wouldn't work.<h1 id=convert-elf-to-binary>Convert ELF to binary</h1><p>I said that flashing the <code>ELF</code> file we created in the previous step won't work. Let's dive into why it won't work.<p>The Cortex-M4 doesn't know about the <code>ELF</code> file format. It loads programs in a very specific way, and just executes instructions sequentially. In my case, the STM32F4 has a few different boot modes but we'll stick with the default -- booting from main flash memory. The reference manual says this about booting:<blockquote><p>[T]he CPU fetches the top-of-stack value from address 0x0000 0000, then starts code execution from the boot memory starting from 0x0000 0004.</blockquote><p>We won't get too deep into the startup process here. It's covered in <a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#cortex-m4-startup>Cortex M4 startup</a>.<p>The first 4 bytes of the <code>ELF</code> file header are <code>7f 45 4c 46</code>. If we flashed this to the MCU, it would fetch this value and set it to the stack pointer, then start executing spurious instructions. Who knows what would happen in this case. At best, an invalid instruction execution causes an interrupt that resets the MCU. Additionally, the <code>ELF</code> file contains other non-binary data, such as debug sympols, section tables, etc. We don't want the MCU interpreting these data as instructions, so we'll need to convert to a different format.<p>This is where <code>objcopy</code> comes into play. We'll convert our <code>ELF</code> file into a <code>BIN</code> file. <code>objcopy</code>'s man page says this:<blockquote><p>objcopy can be used to generate a raw binary file by using an output target of ‘binary’ (e.g., use -O binary). When objcopy generates a raw binary file, it will essentially produce a memory dump of the contents of the input object file. All symbols and relocation information will be discarded. The memory dump will start at the load address of the lowest section copied into the output file.</blockquote><p>This is what we want -- raw instructions and data to flash onto the MCU. Zig ships with an implementation of <code>objcopy</code>. Let's update our <code>build.zig</code> file to convert the <code>ELF</code> file into a binary file:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>build</span><span>(</span><span style=color:#fdf4c1>b</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>std.Build</span><span>) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const</span><span> exe </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addExecutable</span><span>({
</span><span>        </span><span style=color:#928374;font-style:italic>// -- snip
</span><span>    });
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> bin </span><span style=color:#fe8019>=</span><span> exe.</span><span style=color:#fdf4c1>addObjCopy</span><span>(.{ .format </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .bin </span><span>});
</span><span>    </span><span style=color:#fa5c4b>const</span><span> install_exe </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addInstallArtifact</span><span>(exe, .{});
</span><span>    </span><span style=color:#fa5c4b>const</span><span> install_bin </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addInstallBinFile</span><span>(bin.</span><span style=color:#fdf4c1>getOutput</span><span>(), bin.basename);
</span><span>
</span><span>    b.</span><span style=color:#fdf4c1>getInstallStep</span><span>().</span><span style=color:#fdf4c1>dependOn</span><span>(</span><span style=color:#fe8019>&</span><span>install_bin.step);
</span><span>    install_bin.step.</span><span style=color:#fdf4c1>dependOn</span><span>(</span><span style=color:#fe8019>&</span><span>install_exe.step);
</span><span>}
</span></code></pre><p>After re-running <code>zig build</code>, we now get <code>stm32-test.bin</code> alongside <code>stm32-test</code> in <code>zig-out/bin</code>. Sweet!<h1 id=memory-map-and-linking>Memory map and linking</h1><p>We can avoid this topic no longer. We must now talk about linking and the memory map.<p>Embedded devices typically have small amounts of flash and SRAM. My STM32F401RE has 512K of flash and 92K of SRAM. In addition to flash and data memory, the Cortex-M4 has memory-mapped peripherals. Even though the <em>amount</em> flash and data memory is small, the <em>address space</em> is quite large with 4G of addressable memory.<p>First, lets take a look at how the linker put our <code>ELF</code> together:<pre style=color:#fdf4c1aa;background-color:#282828><code><span>❯ arm-none-eabi-objdump -h zig-out/bin/stm32-test
</span><span>
</span><span>zig-out/bin/stm32-test:     file format elf32-littlearm
</span><span>
</span><span>Sections:
</span><span>Idx Name          Size      VMA       LMA       File off  Algn
</span><span>  0 .ARM.exidx    00000a50  000100f4  000100f4  000000f4  2**2
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span>  1 .rodata       00001db8  00010b48  00010b48  00000b48  2**3
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span>  2 .ARM.extab    00000b7c  00012900  00012900  00002900  2**2
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span>  3 .text         0001f604  0002347c  0002347c  0000347c  2**2
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span><span>  4 .data         00000004  00052a80  00052a80  00022a80  2**2
</span><span>
</span><span>// -- snip
</span></code></pre><p>Note two key headings in the output of <code>objdump</code>: VMA and LMA. GNU's ld has a great description of VMA and LMA, so I'll let them do the talking:<blockquote><p>Every loadable or allocatable output section has two addresses. The first is the VMA, or virtual memory address. This is the address the section will have when the output file is run. The second is the LMA, or load memory address. This is the address at which the section will be loaded. In most cases the two addresses will be the same. An example of when they might be different is when a data section is loaded into ROM, and then copied into RAM when the program starts up (this technique is often used to initialize global variables in a ROM based system). In this case the ROM address would be the LMA, and the RAM address would be the VMA.</blockquote><p>In other words, LMA is the physical address in the MCU's memory, whereas VMA is the address within the MCU's memory map.<p>We need to tell the linker how to lay out each section of our <code>ELF</code> file so that we can flash it to the target and ensure it executes the instructions we want it to. In order to do this, we'll need a custom linker script.<h2 id=linker-script>Linker script</h2><p>There are so many good resources out there regarding linker scripts. I will only briefly explain the parts of the linker script as it relates to the Cortext-M4. If you want more in-depth information on linker scripts, refer to the references below.<p>Before we get started, let's tell Zig to use this linker script:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>build</span><span>(</span><span style=color:#fdf4c1>b</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>std.Build</span><span>) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const</span><span> exe </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addExecutable</span><span>({
</span><span>        </span><span style=color:#928374;font-style:italic>// -- snip
</span><span>    });
</span><span>    exe.</span><span style=color:#fdf4c1>setLinkerScript</span><span>(b.</span><span style=color:#fdf4c1>path</span><span>(</span><span style=color:#b8bb26>"stm32f401re.ld"</span><span>));
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip
</span><span>}
</span></code></pre><h3 id=memory-regions>Memory Regions</h3><p>We need to tell our linker about the memory layout of our target. We do so using the <a href=https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_16.html><code>MEMORY</code></a> keyword:<pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fdf4c1>FLASH_SIZE</span><span> = </span><span style=color:#d3869b>0x80000</span><span>; </span><span style=color:#928374;font-style:italic>/* 512k flash */
</span><span style=color:#fdf4c1>SRAM_SIZE</span><span> = </span><span style=color:#d3869b>0x17000</span><span>; </span><span style=color:#928374;font-style:italic>/* 92k sram */
</span><span style=color:#fdf4c1>STACK_SIZE</span><span> = </span><span style=color:#d3869b>0x800</span><span>; </span><span style=color:#928374;font-style:italic>/* 2k stack */
</span><span>
</span><span style=color:#fa5c4b>MEMORY
</span><span>{
</span><span>    </span><span style=color:#fdf4c1>flash</span><span> (</span><span style=color:#fdf4c1>rx</span><span>) : </span><span style=color:#fa5c4b>ORIGIN</span><span> = </span><span style=color:#d3869b>0x08000000</span><span>, </span><span style=color:#fa5c4b>LENGTH</span><span> = </span><span style=color:#fdf4c1>FLASH_SIZE
</span><span>    </span><span style=color:#fdf4c1>sram</span><span> (</span><span style=color:#fdf4c1>rwx</span><span>) : </span><span style=color:#fa5c4b>ORIGIN</span><span> = </span><span style=color:#d3869b>0x20000000</span><span>, </span><span style=color:#fa5c4b>LENGTH</span><span> = </span><span style=color:#fdf4c1>SRAM_SIZE
</span><span>}
</span></code></pre><p>Here, we define our flash as a 512K region of read-only memory beginning at address <code>0x0800_0000</code> and our sram as a 92K region of read-write memory beginning at address <code>0x2000_0000</code>. We'll use the <code>STACK_SIZE</code> variable later.<h3 id=entry-point>Entry point</h3><p>The linker needs an entry point. Let's define our entry point as the first vector in our vector table, <code>resetHandler</code> (see <a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#vector-table>vector table</a> below):<pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fa5c4b>ENTRY</span><span>(</span><span style=color:#fdf4c1>resetHandler</span><span>)
</span></code></pre><h3 id=sections>Sections</h3><p>Next we define the layout of our output file with the <a href=https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_18.html#SEC18><code>SECTIONS</code></a> keyword:<pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fa5c4b>SECTIONS
</span><span>{
</span><span>}
</span></code></pre><h4 id=text-section><code>.text</code> section</h4><pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fa5c4b>SECTIONS
</span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>
</span><span>    </span><span style=color:#fdf4c1>.text</span><span> :
</span><span>    {
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>4</span><span>);
</span><span>        </span><span style=color:#fa5c4b>LONG</span><span>(</span><span style=color:#fdf4c1>__initial_stack_pointer</span><span>)
</span><span>        </span><span style=color:#fa5c4b>KEEP</span><span>(*(</span><span style=color:#fdf4c1>.vectors</span><span>))
</span><span>        *(</span><span style=color:#fdf4c1>.text</span><span>*)
</span><span>        *(</span><span style=color:#fdf4c1>.rodata</span><span>*)
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>4</span><span>);
</span><span>    } > </span><span style=color:#fdf4c1>flash
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>}
</span></code></pre><p>Quite a lot is happening here. Let's break it down line-by-line:<ul><li>align the <code>.text</code> section on a 4-byte boundary<li>reserve 4-bytes at the start of the <code>.text</code> section for the initial stack pointer<li>place the vector table immediatly after our initial stack pointer<li>place the code following the reset vectors<li>place read-only data after the code<li>align the end of the <code>.text</code> section on a 4-byte boundary</ul><h4 id=stack-section><code>.stack</code> section</h4><p>Next comes the stack section. We'll reserve spack for our stack using the <code>STACK_SIZE</code> variable we created earlier. Note that the <a href=https://github.com/ARM-software/abi-aa/blob/main/aapcs32/aapcs32.rst>ARM Procedure Call Standard (AAPCS)</a> says that the stack must be double word (8-byte) aligned, not single word (4-byte).<pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fa5c4b>SECTIONS
</span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>
</span><span>    </span><span style=color:#fdf4c1>.stack</span><span> (</span><span style=color:#fdf4c1>NOLOAD</span><span>) :
</span><span>    {
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>8</span><span>);
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fdf4c1>.</span><span> + </span><span style=color:#fdf4c1>STACK_SIZE</span><span>;
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>8</span><span>);
</span><span>        </span><span style=color:#fdf4c1>__initial_stack_pointer</span><span> = </span><span style=color:#fdf4c1>.</span><span>;
</span><span>    } > </span><span style=color:#fdf4c1>sram
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>}
</span></code></pre><ul><li>align the bottom of the stack on an 8-byte boundary<li>reserve space for stack defined by <code>STACK_SIZE</code><li>align the top of the stack on an 8-byte boundary<li>set the <code>__initial_stack_pointer</code> to the current position</ul><h4 id=data-section><code>.data</code> section</h4><pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fa5c4b>SECTIONS
</span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>
</span><span>    </span><span style=color:#fdf4c1>.data</span><span> :
</span><span>    {
</span><span>        </span><span style=color:#fdf4c1>_sdata</span><span> = </span><span style=color:#fdf4c1>.</span><span>;
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>4</span><span>);
</span><span>        *(</span><span style=color:#fdf4c1>.data</span><span>*)
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>4</span><span>);
</span><span>        </span><span style=color:#fdf4c1>_edata</span><span> = </span><span style=color:#fdf4c1>.</span><span>;
</span><span>    } > </span><span style=color:#fdf4c1>sram </span><span style=color:#fa5c4b>AT</span><span>> </span><span style=color:#fdf4c1>flash
</span><span>
</span><span>    </span><span style=color:#fdf4c1>_ldata</span><span> = </span><span style=color:#fdf4c1>LOADADDR</span><span>(</span><span style=color:#fdf4c1>.data</span><span>);
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>}
</span></code></pre><ul><li>align the <code>.data</code> section on a 4-byte boundary<li>define a symbol <code>_sdata</code> that marks the start of the <code>.data</code> section<li>place initialized data in the output file<li>define a symbol <code>_edata</code> that marks the end of the <code>.data</code> section<li>align the <code>.data</code> section on a 4-byte boundary<li>define a symbol <code>_ldata</code> that holds the LMA of our <code>.data</code> section</ul><p>Note the last part <code>> sram AT> flash</code>. This tells the linker that we want to put the data in the <code>sram</code> region of memory, but we're going to load it from the <code>flash</code> region. This is important for understanding <a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#before-main>what happens before <code>main()</code></a>.<h4 id=bss-section><code>.bss</code> section</h4><pre class=language-ld data-lang=ld style=color:#fdf4c1aa;background-color:#282828><code class=language-ld data-lang=ld><span style=color:#fa5c4b>SECTIONS
</span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>
</span><span>    </span><span style=color:#fdf4c1>.bss</span><span> (</span><span style=color:#fdf4c1>NOLOAD</span><span>) :
</span><span>    {
</span><span>        </span><span style=color:#fdf4c1>_szero</span><span> = </span><span style=color:#fdf4c1>.</span><span>;
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>4</span><span>);
</span><span>        *(</span><span style=color:#fdf4c1>.bss</span><span>*)
</span><span>        </span><span style=color:#fdf4c1>.</span><span> = </span><span style=color:#fa5c4b>ALIGN</span><span>(</span><span style=color:#d3869b>4</span><span>);
</span><span>        </span><span style=color:#fdf4c1>_ezero</span><span> = </span><span style=color:#fdf4c1>.</span><span>;
</span><span>    } > </span><span style=color:#fdf4c1>sram
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>/* snip */
</span><span>}
</span></code></pre><ul><li>align the <code>.bss</code> section on a 4-byte boundary<li>define a symbol <code>_szero</code> that marks the start of the <code>.bss</code> section<li>place initialized data in the output file<li>define a symbol <code>_ezero</code> that marks the end of the <code>.bss</code> section<li>the <code>.bss</code> section on a 4-byte boundary</ul><p>References: <sup class=footnote-reference><a href=#2>2</a></sup> <sup class=footnote-reference><a href=#3>3</a></sup><h1 id=vector-table>The vector table</h1><p>In the previous section, we put the vector table (<code>.vectors</code>) at the start of the <code>.text</code> section preceded only by the 4-byte initial stack pointer. Let's define our vector table in Zig:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>resetHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>nmiHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>hardFaultHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>memManageHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>busFaultHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>usageFaultHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>svCallHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>debugMonitorHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>pendSvHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>sysTickHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{}
</span><span>
</span><span style=color:#fa5c4b>export const</span><span> vectors </span><span style=color:#fa5c4b>linksection</span><span>(</span><span style=color:#b8bb26>".vectors"</span><span>) </span><span style=color:#fe8019>=</span><span> [</span><span style=color:#d3869b>_</span><span>]</span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>const fn </span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void</span><span>{
</span><span>    resetHandler,
</span><span>    nmiHandler,
</span><span>    hardFaultHandler,
</span><span>    memManageHandler,
</span><span>    busFaultHandler,
</span><span>    usageFaultHandler,
</span><span>    </span><span style=color:#d3869b>null</span><span>, </span><span style=color:#928374;font-style:italic>// reserved
</span><span>    </span><span style=color:#d3869b>null</span><span>, </span><span style=color:#928374;font-style:italic>// reserved
</span><span>    </span><span style=color:#d3869b>null</span><span>, </span><span style=color:#928374;font-style:italic>// reserved
</span><span>    </span><span style=color:#d3869b>null</span><span>, </span><span style=color:#928374;font-style:italic>// reserved
</span><span>    svCallHandler,
</span><span>    debugMonitorHandler,
</span><span>    </span><span style=color:#d3869b>null</span><span>, </span><span style=color:#928374;font-style:italic>// reserved
</span><span>    pendSvHandler,
</span><span>    sysTickHandler,
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip: continued for MCU-specific interrupts; consult datasheet
</span><span>};
</span></code></pre><p>Here, we create our vector table, which is an array of function pointers having the signature:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>const fn </span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) void
</span></code></pre><p>Each index in the array corresponds to an interrupt vector. The elements containing <code>null</code> values are reserved. The first 15 bytes of this table will be identical across all Cortex-M4 MCUs. After that, each MCU will have its own order for device-specific interrupts.<p>The <code>linksection(".vectors")</code> tells the linker that we want to put this declaration in the <code>.vectors</code> section of the file. This is analogous to <code>__attribute__((section(".vectors")))</code> in GCC.<h1 id=cortex-m4-startup>Cortex-M4 startup</h1><p>Now that we told the linker where to put our code, let's talk about why we put it there. Recall the quote from the datasheet in the <a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#convert-elf-to-binary>Convert ELF to binary</a> section:<blockquote><p>[T]he CPU fetches the top-of-stack value from address 0x0000 0000, then starts code execution from the boot memory starting from 0x0000 0004.</blockquote><p>When the MCU boots up, the first thing it does is fetch the value at address <code>0x0000_0000</code> and uses it as its stack pointer. There are a couple of interesting things to note here. First, the address <code>0x0000_0000</code> is aliased to <code>0x0800_0000</code> (see footnote <sup class=footnote-reference><a href=#4>4</a></sup> for more info). This means that our <code>__initial_stack_pointer</code> we put at <code>0x0800_0000</code> is accessible also from <code>0x0000_0000</code>.<p>After our stack pointer is loaded, the MCU proceeds to <code>0x0000_0004</code> and starts executing instructions.<p>Let's take a closer look at our output file. First, let's check out the section table:<pre style=color:#fdf4c1aa;background-color:#282828><code><span>❯ arm-none-eabi-objdump -h zig-out/bin/stm32-test
</span><span>
</span><span>zig-out/bin/stm32-test:     file format elf32-littlearm
</span><span>
</span><span>Sections:
</span><span>Idx Name          Size      VMA       LMA       File off  Algn
</span><span>  0 .text         0000000c  08000000  08000000  00010000  2**2
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, CODE
</span><span>  1 .ARM.exidx    00000010  0800000c  0800000c  0001000c  2**2
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span>  2 .stack        00000800  20000000  20000000  00020000  2**0
</span><span>                  ALLOC, READONLY
</span><span>  3 .data         00000000  20000800  20000000  00020000  2**0
</span><span>                  CONTENTS, ALLOC, LOAD, READONLY, DATA
</span><span>  4 .bss          00000000  20000800  20000800  00020000  2**0
</span><span>                  ALLOC
</span><span>  5 .ARM.attributes 0000003f  00000000  00000000  00020000  2**0
</span><span>                  CONTENTS, READONLY
</span><span>  6 .comment      00000067  00000000  00000000  0002003f  2**0
</span><span>                  CONTENTS, READONLY
</span></code></pre><p>Here, we see:<ul><li><code>.text</code> section starting at <code>0x0800_0000</code> corresponding with the start of the <code>flash</code> region<li><code>.stack</code> section starting at <code>0x2000_0000</code> corresponding with the start of the <code>sram</code> region and having a length of <code>0x800</code><li><code>.data</code> section starting immediately after our <code>.stack</code> section<li><code>.bss</code> section starting immediately after our <code>.data</code> section</ul><pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#8ec07c>❯ arm</span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>none</span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>eabi</span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>objdump </span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>d </span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>j .text zig</span><span style=color:#fdf4c1>-</span><span style=color:#fa5c4b>out</span><span style=color:#8ec07c>/bin/stm32</span><span style=color:#fdf4c1>-</span><span style=color:#fa5c4b>test </span><span style=color:#8ec07c>| head </span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>n </span><span style=color:#d3869b>20
</span><span>
</span><span style=color:#8ec07c>zig</span><span style=color:#fdf4c1>-</span><span style=color:#fa5c4b>out</span><span style=color:#8ec07c>/bin/stm32</span><span style=color:#fdf4c1>-</span><span style=color:#fa5c4b>test</span><span style=color:#8ec07c>:     file form</span><span style=color:#fabd2f>at </span><span style=color:#8ec07c>elf32</span><span style=color:#fdf4c1>-</span><span style=color:#8ec07c>littlearm
</span><span>
</span><span>
</span><span style=color:#8ec07c>Disassembly of </span><span style=color:#fabd2f>section </span><span style=color:#8ec07c>.text:
</span><span>
</span><span style=color:#d3869b>08000000 </span><span style=color:#8ec07c>&LTvectors</span><span style=color:#fdf4c1>-</span><span style=color:#d3869b>0x4</span><span style=color:#8ec07c>>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000000</span><span style=color:#8ec07c>:       </span><span style=color:#d3869b>20000800        </span><span style=color:#8ec07c>andcs   r0</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>r0</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>r0</span><span style=color:#fdf4c1>, </span><span style=color:#fa5c4b>lsl </span><span style=color:#8ec07c>#</span><span style=color:#d3869b>16
</span><span>
</span><span style=color:#d3869b>08000004 </span><span style=color:#8ec07c>&LTvectors>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000004</span><span style=color:#8ec07c>:       </span><span style=color:#d3869b>08000059 </span><span style=color:#8ec07c>0800005d </span><span style=color:#d3869b>08000061 08000065     </span><span style=color:#8ec07c>Y...</span><span style=color:#fdf4c1>]</span><span style=color:#8ec07c>...a...e...
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000014</span><span style=color:#8ec07c>:       </span><span style=color:#d3869b>08000069 </span><span style=color:#8ec07c>0800006d </span><span style=color:#d3869b>00000000 00000000     </span><span style=color:#8ec07c>i...m...........
</span><span style=color:#8ec07c>        ...
</span><span style=color:#8ec07c> 800002c:       </span><span style=color:#d3869b>08000071 08000075 00000000 08000079     </span><span style=color:#8ec07c>q...u.......y...
</span><span style=color:#8ec07c> 800003c:       0800007d                                }...
</span></code></pre><p>Here, we see the value <code>20000800</code>, which corresponds to the top of our stack. This is the <code>__initial_stack_pointer</code> we reserved in the <code>.text</code> section and defined in the <code>.stack</code> section of our linker script. The following few addresses are our interrupt vectors that were placed in the <code>.text</code> section. How cool is that!<h1 id=before-main>What happens before <code>main()</code>?</h1><p>When we compile an application on our PCs, we might assume that the entry point for the application is the <code>main()</code> function. If you assumed that, you're half right. The <code>main</code> function is the entry point <em>your</em> application, but that's not what the operating system calls. The operating system calls the <code>_start()</code> function, which is usually provided by your libc.<p>When you build a C/C++ application for Linux, your system's libc implementation is implicitly linked to your application, which includes a piece of code called the "startup code". The startup code does things like initilize <code>argc</code> and <code>argv</code>, call constructors, and so on. I won't get into too much detail here. Instead, check out the references below for some deep-dives.<p>Even though we set our <a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#entry-point>entry point</a> above, we'll still need to define our <code>_start()</code> symbol, otherwise the linker complains at us. Let's add the following to our <code>main.zig</code>:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>_start</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fdf4c1>main</span><span>();
</span><span>
</span><span>    </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#d3869b>true</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>asm volatile </span><span>(</span><span style=color:#b8bb26>"nop"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>We implement an exported <code>_start()</code> function that just calls <code>main()</code>. If main returns (which it shouldn't), we'll just hang in an infinite loop.<p>Here's what code got generated:<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>08000040 </span><span style=color:#8ec07c><_start>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000040</span><span style=color:#8ec07c>:       b580            </span><span style=color:#fa5c4b>push    </span><span style=color:#8ec07c>{r7</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>lr}
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000042</span><span style=color:#8ec07c>:       466f            </span><span style=color:#fa5c4b>mov     </span><span style=color:#8ec07c>r7</span><span style=color:#fdf4c1>, sp
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000044</span><span style=color:#8ec07c>:       f000 f804       </span><span style=color:#fdf4c1>bl      </span><span style=color:#d3869b>8000050 </span><span style=color:#8ec07c>&LTmain.main>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000048</span><span style=color:#8ec07c>:       e7ff            b.n     800004a <_start</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0xa</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> 800004a:       bf00            </span><span style=color:#fa5c4b>nop
</span><span style=color:#8ec07c> 800004c:       e7fd            b.n     800004a <_start</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0xa</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> 800004e:       bf00            </span><span style=color:#fa5c4b>nop
</span><span>
</span><span style=color:#d3869b>08000050 </span><span style=color:#8ec07c>&LTmain.main>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000050</span><span style=color:#8ec07c>:       e7ff            b.n     </span><span style=color:#d3869b>8000052 </span><span style=color:#8ec07c>&LTmain.main</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0x2</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000052</span><span style=color:#8ec07c>:       bf00            </span><span style=color:#fa5c4b>nop
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000054</span><span style=color:#8ec07c>:       e7fd            b.n     </span><span style=color:#d3869b>8000052 </span><span style=color:#8ec07c>&LTmain.main</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0x2</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000056</span><span style=color:#8ec07c>:       bf00            </span><span style=color:#fa5c4b>nop
</span><span>
</span><span style=color:#d3869b>08000058 </span><span style=color:#8ec07c>&LTresetHandler>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000058</span><span style=color:#8ec07c>:       </span><span style=color:#d3869b>4770            </span><span style=color:#fdf4c1>bx      </span><span style=color:#8ec07c>lr
</span><span style=color:#8ec07c> 800005a:       bf00            </span><span style=color:#fa5c4b>nop
</span></code></pre><p>Awesome, we made it to <code>main()</code>! You'd expect this to work once flashed to the MCU, right? Well, you're in for disappointment. Review the Cortex-M4 startup process: we fetch the stack pointer and begin executing instructions at <code>0x0000_0004</code>, which is our reset handler. However, our reset handler doesn't do anything, so main will never be called.<p>In order to fix this, <code>resetHandler()</code> needs to call <code>_start()</code>:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>resetHandler</span><span>() </span><span style=color:#fa5c4b>callconv</span><span>(.C) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fdf4c1>_start</span><span>();
</span><span>}
</span></code></pre><p>That gives us the following:<pre class=language-asm data-lang=asm style=color:#fdf4c1aa;background-color:#282828><code class=language-asm data-lang=asm><span style=color:#d3869b>08000040 </span><span style=color:#8ec07c><_start>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000040</span><span style=color:#8ec07c>:       b580            </span><span style=color:#fa5c4b>push    </span><span style=color:#8ec07c>{r7</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>lr}
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000042</span><span style=color:#8ec07c>:       466f            </span><span style=color:#fa5c4b>mov     </span><span style=color:#8ec07c>r7</span><span style=color:#fdf4c1>, sp
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000044</span><span style=color:#8ec07c>:       f000 f804       </span><span style=color:#fdf4c1>bl      </span><span style=color:#d3869b>8000050 </span><span style=color:#8ec07c>&LTmain.main>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000048</span><span style=color:#8ec07c>:       e7ff            b.n     800004a <_start</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0xa</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> 800004a:       bf00            </span><span style=color:#fa5c4b>nop
</span><span style=color:#8ec07c> 800004c:       e7fd            b.n     800004a <_start</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0xa</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> 800004e:       bf00            </span><span style=color:#fa5c4b>nop
</span><span>
</span><span style=color:#d3869b>08000050 </span><span style=color:#8ec07c>&LTmain.main>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000050</span><span style=color:#8ec07c>:       e7ff            b.n     </span><span style=color:#d3869b>8000052 </span><span style=color:#8ec07c>&LTmain.main</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0x2</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000052</span><span style=color:#8ec07c>:       bf00            </span><span style=color:#fa5c4b>nop
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000054</span><span style=color:#8ec07c>:       e7fd            b.n     </span><span style=color:#d3869b>8000052 </span><span style=color:#8ec07c>&LTmain.main</span><span style=color:#fdf4c1>+</span><span style=color:#d3869b>0x2</span><span style=color:#8ec07c>>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000056</span><span style=color:#8ec07c>:       bf00            </span><span style=color:#fa5c4b>nop
</span><span>
</span><span style=color:#d3869b>08000058 </span><span style=color:#8ec07c>&LTresetHandler>:
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000058</span><span style=color:#8ec07c>:       b580            </span><span style=color:#fa5c4b>push    </span><span style=color:#8ec07c>{r7</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>lr}
</span><span style=color:#8ec07c> 800005a:       466f            </span><span style=color:#fa5c4b>mov     </span><span style=color:#8ec07c>r7</span><span style=color:#fdf4c1>, sp
</span><span style=color:#8ec07c> 800005c:       f7ff fff0       </span><span style=color:#fdf4c1>bl      </span><span style=color:#d3869b>8000040 </span><span style=color:#8ec07c><_start>
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000060</span><span style=color:#8ec07c>:       bd80            </span><span style=color:#fa5c4b>pop     </span><span style=color:#8ec07c>{r7</span><span style=color:#fdf4c1>, </span><span style=color:#8ec07c>pc}
</span><span style=color:#8ec07c> </span><span style=color:#d3869b>8000062</span><span style=color:#8ec07c>:       bf00            </span><span style=color:#fa5c4b>nop
</span></code></pre><p>Now we can see that <code>resetHandler()</code> calls <code>_start()</code>, which calls <code>main()</code>. Are we there yet? Technically, yes - but we still have work to do. If you're working entirely on the stack and don't rely on preinitialized memory, you can get started, and even make an LED blink.<p>However, in most cases, you'll want to load up your memory from the <code>.data</code> and <code>.bss</code> sections -- this is not done for you automatically like it is when you run a program on your computer. Embedded startup code must explicitly perform this step.<p>To do this, we'll need to refer back to the symbols we created in the linker script:<ul><li><code>_sdata</code>: the start of the <code>.data</code> section<li><code>_edata</code>: the end of the <code>.data</code> section<li><code>_ldata</code>: the LMA of the <code>.data</code> section<li><code>_szero</code>: the start of the <code>.bss</code> section<li><code>_ezero</code>: the end of the <code>.bss</code> section</ul><p>For our <code>.bss</code> section, we need to zero out all memory between <code>_szero</code> and <code>_ezero</code>. For the <code>.data</code> section, we need to copy the memory from <code>_ldata</code> into the memory from <code>_sdata</code> to <code>_edata</code>. Let's do this in our <code>_start()</code> function:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>extern var </span><span style=color:#fdf4c1>_szero</span><span>: u32;
</span><span style=color:#fa5c4b>extern var </span><span style=color:#fdf4c1>_ezero</span><span>: u32;
</span><span style=color:#fa5c4b>extern var </span><span style=color:#fdf4c1>_sdata</span><span>: u32;
</span><span style=color:#fa5c4b>extern var </span><span style=color:#fdf4c1>_edata</span><span>: u32;
</span><span style=color:#fa5c4b>extern var </span><span style=color:#fdf4c1>_ldata</span><span>: u32;
</span><span>
</span><span style=color:#fa5c4b>export fn </span><span style=color:#8ec07c>_start</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>szero</span><span>: [</span><span style=color:#fe8019>*</span><span>]</span><span style=color:#fa5c4b>u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrCast</span><span>(</span><span style=color:#fe8019>&</span><span>_szero);
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>sdata</span><span>: [</span><span style=color:#fe8019>*</span><span>]</span><span style=color:#fa5c4b>u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrCast</span><span>(</span><span style=color:#fe8019>&</span><span>_sdata);
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>ldata</span><span>: [</span><span style=color:#fe8019>*</span><span>]</span><span style=color:#fa5c4b>u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrCast</span><span>(</span><span style=color:#fe8019>&</span><span>_ldata);
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> bss_len </span><span style=color:#fe8019>=</span><span> _ezero </span><span style=color:#fe8019>-</span><span> _szero;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(bss_len </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#fabd2f>@memset</span><span>(szero[</span><span style=color:#d3869b>0 </span><span style=color:#fe8019>..</span><span> _ezero </span><span style=color:#fe8019>-</span><span> _szero], </span><span style=color:#d3869b>0</span><span>);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> data_len </span><span style=color:#fe8019>=</span><span> _edata </span><span style=color:#fe8019>-</span><span> _sdata;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(data_len </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#fabd2f>@memcpy</span><span>(sdata[0</span><span style=color:#fe8019>..</span><span>data_len], ldata[0</span><span style=color:#fe8019>..</span><span>data_len]);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fdf4c1>main</span><span>();
</span><span>
</span><span>    </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#d3869b>true</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>asm volatile </span><span>(</span><span style=color:#b8bb26>"nop"</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>And there you have it! We've reached main! That's a lot of stuff happening under the hood... Note that your startup code isn't limited to initilizing system memory. The possibilities are endless. One thing you might consider putting in your startup code is system clock setup. But that's outside the scope of this project, for now at least.<p>References: <sup class=footnote-reference><a href=#5>5</a></sup> <sup class=footnote-reference><a href=#6>6</a></sup><h1 id=flashing>Flashing</h1><p>As I mentioned earlier, I'm using OpenOCD to flash the MCU. I created a step in <code>build.zig</code> that would do this for me:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub const </span><span style=color:#fdf4c1>build</span><span>(</span><span style=color:#fdf4c1>b</span><span>: </span><span style=color:#fe8019>*</span><span>std.Build) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> flash_run </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>addSystemCommand</span><span>(&.{
</span><span>        </span><span style=color:#b8bb26>"openocd"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"-f"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"/usr/share/openocd/scripts/board/st_nucleo_f4.cfg"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"-c"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"init"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"-c"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"reset halt; flash write_image erase zig-out/bin/stm32-test.bin 0x08000000 bin"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"-c"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"flash verify_image zig-out/bin/stm32-test.bin 0x08000000 bin"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"-c"</span><span>,
</span><span>        </span><span style=color:#b8bb26>"reset run; shutdown"</span><span>,
</span><span>    });
</span><span>    </span><span style=color:#fa5c4b>const</span><span> flash_step </span><span style=color:#fe8019>=</span><span> b.</span><span style=color:#fdf4c1>step</span><span>(</span><span style=color:#b8bb26>"flash"</span><span>, </span><span style=color:#b8bb26>"Flash the code to the target"</span><span>);
</span><span>
</span><span>    flash_run.step.</span><span style=color:#fdf4c1>dependOn</span><span>(</span><span style=color:#fe8019>&</span><span>install_bin.step);
</span><span>    flash_step.</span><span style=color:#fdf4c1>dependOn</span><span>(</span><span style=color:#fe8019>&</span><span>flash_run.step);
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip
</span><span>}
</span><span style=color:#fa5c4b>const</span><span> std </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"std"</span><span>);
</span></code></pre><p>To flash the MCU, all I need to do is <code>zig build flash</code>. The artifacts are rebuilt only when needed, and flashing is handled via the system command to <code>openocd</code>.<h1 id=blink-a-damn-led>Blink a damn LED</h1><p>The NUCLEO-F401RE development board has an LED wired up to GPIO <code>PA5</code>. Before anything else, the GPIO A clocks need to be enabled on the <code>AHB1</code> bus. We do this by setting the <code>GPIOA EN</code> bit in the <code>RCC_AHB1ENR</code> register. After that' we're free to configure the GPIO pin as an output and toggle the <code>ODR</code> register to turn the LED on and off.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>rcc_ahb1enr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_3830</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>gpio_a_mode</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_0000</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>gpio_a_odr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_0014</span><span>);
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    rcc_ahb1enr</span><span style=color:#fe8019>.* |= </span><span style=color:#d3869b>1</span><span>;
</span><span>    gpio_a_mode</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>10</span><span>);
</span><span>    gpio_a_odr</span><span style=color:#fe8019>.* = </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#d3869b>true</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>for </span><span>(0</span><span style=color:#fe8019>..</span><span style=color:#d3869b>1000000</span><span>) </span><span style=color:#fe8019>|</span><span style=color:#d3869b>_</span><span style=color:#fe8019>| </span><span>{
</span><span>            </span><span style=color:#fa5c4b>asm volatile </span><span>(</span><span style=color:#b8bb26>"nop"</span><span>);
</span><span>        }
</span><span>
</span><span>        gpio_a_odr</span><span style=color:#fe8019>.* ^= </span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>5</span><span>;
</span><span>    }
</span><span>}
</span></code></pre><h1 id=hello-world>Hello, world!</h1><p>Next, we need to enable the UART. On my board, USART2 (GPIO <code>PA2</code> & <code>PA3</code>) is exposed over to the ST-Link. In rough steps, we need to do the following:<ol><li>enable <code>APB1</code> bus clocks for USART2<li>set GPIO mode to alternate function<li>configure alternate function to USART2<li>enable USART2<li>configure the baud rate<li>enable the transmitter<li>send data</ol><p>Here's what I came up with:<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>rcc_ahb1enr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_3830</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>rcc_apb1enr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_3840</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>gpio_a_moder</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_0000</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>gpio_a_odr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_0014</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>gpio_a_aflr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4002_0020</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>usart_2_sr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4000_4400</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>usart_2_dr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4000_4404</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>usart_2_brr</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4000_4408</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>usart_2_cr1</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>volatile u32 </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@ptrFromInt</span><span>(</span><span style=color:#d3869b>0x4000_440c</span><span>);
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    rcc_ahb1enr</span><span style=color:#fe8019>.* |= </span><span style=color:#d3869b>1</span><span>;
</span><span>    rcc_apb1enr</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>17</span><span>);
</span><span>
</span><span>    gpio_a_moder</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>10</span><span>);
</span><span>    gpio_a_odr</span><span style=color:#fe8019>.* = </span><span style=color:#d3869b>0</span><span>;
</span><span>
</span><span>    gpio_a_moder</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>2 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>6</span><span>) </span><span style=color:#fe8019>| </span><span>(</span><span style=color:#d3869b>2 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>4</span><span>);
</span><span>    gpio_a_aflr</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>7 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>8</span><span>) </span><span style=color:#fe8019>| </span><span>(</span><span style=color:#d3869b>7 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>12</span><span>);
</span><span>
</span><span>    usart_2_cr1</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>13</span><span>);
</span><span>    usart_2_brr</span><span style=color:#fe8019>.* |= </span><span style=color:#d3869b>0xffff</span><span> & ((</span><span style=color:#d3869b>8 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>4</span><span>) </span><span style=color:#fe8019>| </span><span>(</span><span style=color:#d3869b>11</span><span>));
</span><span>    usart_2_cr1</span><span style=color:#fe8019>.* |= </span><span>(</span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>3</span><span>);
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> xmit_str </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"Hello, world!\r\n"</span><span>;
</span><span>    </span><span style=color:#fa5c4b>var</span><span> xmit </span><span style=color:#fe8019>= </span><span style=color:#d3869b>false</span><span>;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>while </span><span>(</span><span style=color:#d3869b>true</span><span>) {
</span><span>        </span><span style=color:#fa5c4b>if </span><span>(</span><span style=color:#fe8019>!</span><span>xmit) {
</span><span>            xmit </span><span style=color:#fe8019>= </span><span style=color:#d3869b>true</span><span>;
</span><span>
</span><span>            </span><span style=color:#fa5c4b>for </span><span>(xmit_str) </span><span style=color:#fe8019>|</span><span>c</span><span style=color:#fe8019>| </span><span>{
</span><span>                </span><span style=color:#fa5c4b>while </span><span>(usart_2_sr</span><span style=color:#fe8019>.*</span><span> & (</span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>7</span><span>) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {}
</span><span>                usart_2_dr</span><span style=color:#fe8019>.* |=</span><span> c;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#fa5c4b>for </span><span>(0</span><span style=color:#fe8019>..</span><span style=color:#d3869b>1000000</span><span>) </span><span style=color:#fe8019>|</span><span style=color:#d3869b>_</span><span style=color:#fe8019>| </span><span>{
</span><span>            </span><span style=color:#fa5c4b>asm volatile </span><span>(</span><span style=color:#b8bb26>"nop"</span><span>);
</span><span>        }
</span><span>
</span><span>        gpio_a_odr</span><span style=color:#fe8019>.* ^= </span><span style=color:#d3869b>1 </span><span style=color:#fe8019><< </span><span style=color:#d3869b>5</span><span>;
</span><span>    }
</span><span>}
</span></code></pre><p>Attaching to the serial port and flashing the code gives me what I want:<pre style=color:#fdf4c1aa;background-color:#282828><code><span>Hello, world!
</span></code></pre><h1 id=conclusion>Conclusion</h1><p>If you couldn't tell, I'm getting burned out writing this. This post has taken me the better part of a day. Even though it's somewhat laborious, I accomplished my goal of getting "Hello, World!" printed to my terminal from an embedded device without any dependencies within the time limit I imposed on myself.<p>The code is not particularly readable, though. The register access is esoteric, and there's no documentation about what each value means. However, there are some pretty elegant ways of solving that problem that I hope to share in a follow-up post. However, that's all for today.<p>Zig has quickly become my favorite language since I picked it up back in February when it was in <code>0.11.0</code>. We're now in <code>0.13.0</code>. So much has changed, and the <code>0.14.0-dev</code> branch has seemingly more changes than ever. Since <code>0.11.0</code>, the language, its standard library, and its build system have seem massive improvements. If you're looking to try out Zig, there's no better time than now!.<hr><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>I have a lot to say about the Zig build system. Stay tuned for that post!</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p><a href=https://sourceware.org/binutils/docs/ld/Basic-Script-Concepts.html>Basic Linker Script Concepts</a></div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p><a href=https://blog.thea.codes/the-most-thoroughly-commented-linker-script/>The most thoroughly commented linker script (probably)</a></div><div class=footnote-definition id=4><sup class=footnote-definition-label>4</sup><p>The STM32F401RE aliases address <code>0x0000_0000</code> to flash memory at <code>0x0800_0000</code> up to 256KB. In other words, when we reference <code>0x0000_0000</code>, the address is translated to <code>0x0800_0000</code>; when <code>0x0000_0004</code> is accessed, the address is translated to <code>0x0800_0004</code>; and so on. This means that our LMA for flash may be either of these values. This is relevant to understand the <a href=https://www.weskoerber.com/posts/blog/stm32-zig-1/#cortex-m4-startup>Cortex-M4 startup</a> proccess.</div><div class=footnote-definition id=5><sup class=footnote-definition-label>5</sup><p><a href=https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html>A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux</a></div><div class=footnote-definition id=6><sup class=footnote-definition-label>6</sup><p><a href=http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html>Linux x86 Program Start Up</a></div></section></article></main></div>