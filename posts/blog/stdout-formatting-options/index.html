<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Writing better CLI applications
        
    </title><meta content="Writing better CLI applications" property=og:title><link href=https://www.weskoerber.com/fonts.css rel=stylesheet><script async data-goatcounter=https://weskoerber.goatcounter.com/count src=https://www.weskoerber.com/js/count.js></script><noscript><img src="https://weskoerber.goatcounter.com//count?p=/posts/blog/stdout-formatting-options/&t=Writing better CLI applications"></noscript><script src=https://www.weskoerber.com/js/toc.js></script><link title="Wes Koerber" href=https://www.weskoerber.com/atom.xml rel=alternate type=application/atom+xml><link href=https://www.weskoerber.com/theme/light.css rel=stylesheet><link href=https://www.weskoerber.com/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://www.weskoerber.com/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://www.weskoerber.com/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://www.weskoerber.com>Wes Koerber</a><div class=socials><a class=social href=https://github.com/weskoerber rel=me> <img alt=github src=https://www.weskoerber.com/social_icons/github.svg> </a><a class=social href=https://gitlab.com/weskoerber rel=me> <img alt=gitlab src=https://www.weskoerber.com/social_icons/gitlab.svg> </a><a class=social href=https://www.linkedin.com/in/weskoerber/ rel=me> <img alt=linkedin src=https://www.weskoerber.com/social_icons/linkedin.svg> </a><a class=social href=mailto:wes@weskoerber.com rel=me> <img alt=email src=https://www.weskoerber.com/social_icons/email.svg> </a><a class=social href=https://www.weskoerber.com/atom.xml rel=me> <img alt=rss src=https://www.weskoerber.com/social_icons/rss.svg> </a></div></div><nav><a href=https://www.weskoerber.com/posts style=margin-left:.5em>/posts</a><a href=https://www.weskoerber.com/about style=margin-left:.5em>/about</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://www.weskoerber.com/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://www.weskoerber.com/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Writing better CLI applications<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-04-25</time></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://www.weskoerber.com/posts/blog/stdout-formatting-options/#pipelines>Pipelines</a><li><a href=https://www.weskoerber.com/posts/blog/stdout-formatting-options/#the-client-server-model>The client -> server model</a><li><a href=https://www.weskoerber.com/posts/blog/stdout-formatting-options/#exit-codes-and-error-messages>Exit codes and error messages</a><li><a href=https://www.weskoerber.com/posts/blog/stdout-formatting-options/#man-pages>Man pages</a></ul></div><section class=body><p>As programmers, we interact with command line utilities on a daily basis. These days there are so many libraries for creating great utilities from TUIs to simple argument parsers. It also helps that the POSIX and GNU standards for command line arguments is damn near ubiquitous - hell, <a href=https://learn.microsoft.com/en-us/dotnet/standard/commandline/syntax>even Microsoft adopted them</a> <sup class=footnote-reference><a href=#1>1</a></sup>. However, I find that command line utilities are lacking in some areas. In this post, I'll explore some areas I think need improvement, and suggest some alternatives.<h1 id=pipelines>Pipelines</h1><p><a href=https://en.wikipedia.org/wiki/Pipeline_(Unix)>Pipelines</a> are used heavily in Unix-like operating systems, and is often what makes it stand out. Instead of creating large, clunky, and complicated applications that try to implement every feature the authors can think of, the philosophy of Unix is to implement the most basic functionality, and use other programs to perform some further operations.<p>When running command line applications, the output of the application is typically formatted in a way that makes it easily readable by humans. This usually takes the form of a table, grid, or list. This is great for us humans, as it's easy for our brains to read and interpret at a quick glance. But that's not easiest for a machine to parse <sup class=footnote-reference><a href=#2>2</a></sup>. Sure, there's many great utilities like <code>awk</code>, <code>sed</code>, and <code>grep</code>, but I think there's a better way.<p>When a command-line application runs, it could detect whether its <code>stdout</code> is a terminal device or some other handle. For example, <code>stdout</code> could be connected to <code>stdin</code> of another program, in which case it would be a pipe. Applications could detect this and determine the output format to use.<p>Every application has its own way of outputting data. Look at the <code>lsblk</code> and <code>ls</code> commands. They're both tabular data, but you would need to implement parsing logic twice - once for each command. If you have to run many commands, having individual parsing logic for each becomes time-consuming and clutters the actual purpose of your application. Instead, applications should be able to output data in a format that other utilities can accept easily that minimizes the effort required to extract data.<p>For example, if the application's <code>stdout</code> is a terminal, it could output its results in a tabular format. But when <code>stdout</code> is a pipe, maybe it could output its results in some sort of structured text format, such as JSON. This would enable the use of <code>jq</code> to parse the output easily. Or maybe you can send the JSON data to some other environment. Since most languages have libraries that can parse JSON, integration is trivial.<p>There should still be options for overriding this behavior though, since one use-case could be piping results to a pager to view and navigate a high volume of output more easily. In this case, since the application's <code>stdout</code> is a pipe connected to the pager's <code>stdin</code>, the application would output JSON, but we want the tabular format. Here we could explicitly tell the application we want the tabular output style with an option, such as <code>--output-style=tabular</code>.<h1 id=the-client-server-model>The client -> server model</h1><p>In the world of Unix-like operating systems, a pattern you'll see implemented often for applications is to have a daemon process which implements the application's business logic and listens for input via IPC (socket, pipe, shared memory, etc), and a small command-line utility that talks to the daemon process over this IPC channel. There are many utilities that use this pattern:<ul><li>makoctl -> mako (<a href=https://github.com/emersion/mako>repo</a>)<li>nmcli -> NetworkManager (<a href=https://gitlab.freedesktop.org/NetworkManager/NetworkManager>repo</a>)<li>swaymsg -> sway (<a href=https://github.com/swaywm/sway>repo</a>)<li>wpctl -> wireplumber (<a href=https://gitlab.freedesktop.org/pipewire/wireplumber/>repo</a>)<li>Most of systemd, such as: <ul><li>journalctl -> systemd-journald<li>loginctl -> systemd-logind<li>networkctl -> systemd-networkd</ul></ul><p>I think this pattern works really well, because it separates the actual logic of the application and the user interface. It also works really well cross-platform too, particularly on Windows, since services are a special type of application that is non-interactive. It also simplifies environments where you may have multiple users. You only need one daemon process, but you are able to have many client processes talking to the daemon over the IPC channel. Several other aspects of the application are easier to control and manages, such as access control, daemon lifetime management, logging, etc.<p>Of course, this is just not the right pattern for some applications. For example, the <code>ls</code> command doesn't need to be this complex. A much more appropriate invocation strategy is the one-shot method (the way it's currently implemented), where the application launches, it processes its input, does some stuff, then exits.<h1 id=exit-codes-and-error-messages>Exit codes and error messages</h1><p>Most of the time, when applications quit due to an error, the error code is 1. However, there may be many reasons for an application to terminate unexpectedly. How is a user supposed to differentiate between different conditions not being met, errors with input, etc? For example, if a program terminates because a file doesn't exist, how can the user of the application differentiate that between termination due to an invalid option? In my opinion, each error code should correspond to a particular condition. I really don't like the idea of "unknown" or "generic" errors. Most of the time, these errors are not "unknown" or "generic", the author is just too lazy to specifically identify them. Error messages typically take the burden of identifying specific errors by emitting a message to <code>stderr</code>. This isn't easy for applications to parse, since the error messages are often formatted with some input from the user.<p>Error messages in another area that can be improved. Applications such as code compilers have pretty good error messages. The messages are good enough that they often tell you the exact source of the problematic line, and sometimes even the problematic character (such as a missing semi-colon). Rust is the gold standard for compiler errors. We should take a page out of its book and apply it to our command line applications.<h1 id=man-pages>Man pages</h1><p>This one is subjective, but I <em>love</em> man pages. Finding help in a man page is so much quicker than googling, and you don't have to search several links to find what you need. Just <code>man my_application</code> and you have everything you need to know. Applications commonly give you man pages for the usage and purpose of the application. I really like when applications provide man pages for configuration files (e.g. <code>man 5 gitignore</code>). I think more applications should do this.<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>Just to be clear, POSIX doesn't strictly define long options (i.e. <code>--option=value</code>, <code>--option value</code>, or <code>--option</code>), but long options are not inherently incompatible with POSIX-compliant systems.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>What I mean here really is that it's not the easiest to write utilities that parse the output. Optimal machine parsing would be binary data, not text streams.</div></section></article></main></div>