<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Why I'm disabling editor autocomplete
        
    </title><meta content="Why I'm disabling editor autocomplete" property=og:title><link href=https://www.weskoerber.com/fonts.css rel=stylesheet><script async data-goatcounter=https://weskoerber.goatcounter.com/count src=https://www.weskoerber.com/js/count.js></script><noscript><img src="https://weskoerber.goatcounter.com//count?p=/posts/blog/disabling-autocomplete/&t=Why I'm disabling editor autocomplete"></noscript><script src=https://www.weskoerber.com/js/toc.js></script><link title="Wes Koerber" href=https://www.weskoerber.com/atom.xml rel=alternate type=application/atom+xml><link href=https://www.weskoerber.com/theme/light.css rel=stylesheet><link href=https://www.weskoerber.com/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://www.weskoerber.com/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://www.weskoerber.com/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://www.weskoerber.com>Wes Koerber</a><div class=socials><a class=social href=https://github.com/weskoerber rel=me> <img alt=github src=https://www.weskoerber.com/social_icons/github.svg> </a><a class=social href=https://gitlab.com/weskoerber rel=me> <img alt=gitlab src=https://www.weskoerber.com/social_icons/gitlab.svg> </a><a class=social href=https://www.linkedin.com/in/weskoerber/ rel=me> <img alt=linkedin src=https://www.weskoerber.com/social_icons/linkedin.svg> </a><a class=social href=mailto:wes@weskoerber.com rel=me> <img alt=email src=https://www.weskoerber.com/social_icons/email.svg> </a><a class=social href=https://www.weskoerber.com/atom.xml rel=me> <img alt=rss src=https://www.weskoerber.com/social_icons/rss.svg> </a></div></div><nav><a href=https://www.weskoerber.com/posts style=margin-left:.5em>/posts</a><a href=https://www.weskoerber.com/about style=margin-left:.5em>/about</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://www.weskoerber.com/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://www.weskoerber.com/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Why I'm disabling editor autocomplete<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-12-22</time></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#how-i-use-nvim-cmp>How I use nvim-cmp</a><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#what-will-i-use-instead>What will I use instead?</a> <ul><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#telescope>Telescope</a><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#source-code>Source code</a><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#grep>Grep</a><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#automatic-includes>Automatic includes</a><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#man-pages>Man pages</a></ul><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#streamlining-stream-of-conciousness>Streamlining stream-of-conciousness</a><li><a href=https://www.weskoerber.com/posts/blog/disabling-autocomplete/#closing-thoughts>Closing thoughts</a></ul></div><section class=body><p>I've been using Neovim as my text editor for over 2 years now, and I use it for <em>everything</em>: a Personalized Development Environment (<a href="https://www.youtube.com/watch?v=QMVIJhC9Veg">PDE</a>); a note-taking tool using <a href=https://github.com/nvim-neorg/neorg>Neorg</a>; a log reader that handles opening, searching, and writing very large files like a breeze; a man page reader; and so much more.<p>One of the mainstays in my plugin arsenal is <a href=https://github.com/hrsh7th/nvim-cmp><code>nvim-cmp</code></a>, which provides <em>intellisense-style</em> autocompletion. Its collection of <a href=https://github.com/hrsh7th/nvim-cmp/wiki/List-of-sources>completion sources</a> allows extending its functionality into many domains quite easily. It's a very useful plugin and it worked very well for me, <em>and it was one of the main reasons I switched to (and stuck with) Neovim</em>.<p>However, as time went on, I found myself using <code>nvim-cmp</code> <em>less</em> for its intended purpose and <em>more</em> for use cases that are better solved with other plugins and workflows. I found that in trying to <em>shoehorn</em> <code>nvim-cmp</code> into several different tools, my overall productivity <em>diminished</em>. In this post, I'll explain why I'm disabling <code>nvim-cmp</code> (maybe), what I'll use in its place, and how doing so will be of benefit in the long run.<h1 id=how-i-use-nvim-cmp>How I use <code>nvim-cmp</code></h1><p>I realized that my main use of <code>nvim-cmp</code> was for API discovery, <em>especially in languages with namespaces</em> (e.g. <code>C++</code>, <code>C#</code>, <code>Zig</code>). I often found myself begin typing a line by resolving further into the namespace and paging through the list of symbols to see if it had what I wanted. If it did, then I would accept the suggestion and move forward; if it didn't, I would "back out" or "go up" a level in the namespace heirarchy, and try again. Using Zig as an example: <code>std.fs.<...></code>, <code>std.fs.Dir.<...></code>, <code>std.fs.path.<...></code>... and so on, until I found what I was looking for. Once I found it, I could continue with the next "token" in my "stream" of conciousness.<p>However, if I knew <em>exactly</em> what symbol I wanted and <em>exactly</em> where to find it, I didn't really use <code>nvim-cmp</code>. For example, using <code>std.debug.print</code> in Zig or <code>std::cout</code> in C++ (or <code>printf</code>, even), I <em>rarely</em> relied on <code>nvim-cmp</code> for completions. I found that it was <em>quicker</em> for me (and less disruptive) to just type the symbol, <em>letter-by-letter</em>.<p>I am not the fastest typer, either. If I had to guess, I would say I type at around 70-80 words per minute for English prose (such as this blog post, emails--"normal" communication with other humans). That number is lower when writing code. It's difficult to equate the two, since English prose is measured in words per minute, whereas writing code is measured in symbols per minute (probably.. I don't know, just a guess), which for me is probably anywhere from 20-40 percent slower <sup class=footnote-reference><a href=#1>1</a></sup>.<p>Whatever the case may be, it feels <em>a lot</em> faster to just type the exact symbol I need instead of using <code>nvim-cmp</code> to help. Crucially, it feels <em>even faster</em> to type the following symbol because my train of thought hasn't been <em>interrupted</em>. For example, typing <code>std.deb&LTC-y>.pri&LTC-y></code> feels slower than typing <code>std.debug.print</code> (<code>&LTC-y></code> is my completion-accept key).<p><img alt="Zig std.debug.print autocomplete" src=https://www.weskoerber.com/posts/blog/disabling-autocomplete/zig-print-autocomplete.png><h1 id=what-will-i-use-instead>What will I use instead?</h1><p>Of course, I still have a desire for API discoverability and documentation from within Neovim. If <code>nvim-cmp</code> no longer provides this, <em>I'll need some alternatives</em>. Recently, I've been giving <a href=https://github.com/nvim-telescope/telescope.nvim>Telescope</a> a heavier workload, particularly leveraging its <a href=https://github.com/nvim-treesitter/nvim-treesitter>Treesitter</a> integration<h2 id=telescope>Telescope</h2><p>Telescope can show all symbols in a buffer or a workspace. These symbols can be filtered through them using the familiar Telescope interface, add them to the quickfix list, show a preview of the selection, and so on. This method for API discoverability is <em>much more powerful</em>. Most of the time, the documentation <code>nvim-cmp</code> shows comes from the LSP, which in turn gets it from doc-comments in the source code <sup class=footnote-reference><a href=#2>2</a></sup>. Using Telescope's preview, or even putting the result in the quickfix list and opening the source in a new buffer allows a much better experience to read source code and comments within it.<p>This leads us to my next point: <em>reading the source code</em> is often the best way to get <em>accurate</em> and <em>up-to-date</em> documentation.<p><img alt="Telescope buffer symbols" src=https://www.weskoerber.com/posts/blog/disabling-autocomplete/telescope-buffer-symbols.png><h2 id=source-code>Source code</h2><p>If your language or library provides source code and you're not reading it, <em>you're doing yourself a disservice</em>. It's often the best way to figure out what a particular API does. More often than not, documentation in the form of comments is <em>outdated</em>, and could lead you down a rabbit hole. Documentation that's hosted on the web is worse, even if it is autogenerated from comments in the code. Often times the code is updated, but the author forgets to update the doc-comment (hi, it's me, I'm author). This is avoidable if you just <em>read the code</em>!<p>This is not always an option, though. For example, the C standard library that's installed on your distribution only provides <em>header files</em>, not <em>implementations</em> (unless you clone the library, of course). And for languages like C#, you actually need to <em>decompile</em> the runtime to get source code--wild.<h2 id=grep>Grep</h2><p><em>Do not underestimate the power of grep</em>. In languages like C, it can be difficult to navigate through header files, especially if they're nested and inter-dependent. This is where grep makes it easy. If you're looking for a particular symbol, or some verbiage you think may lead you to the symbol, and you're not sure which header file it's in, you can pull one of these:<pre style=color:#fdf4c1aa;background-color:#282828><code><span>$ grep -ire 'IFF_NOARP' /usr/include
</span><span>/usr/include/linux/if.h: * @IFF_NOARP: no ARP protocol. Can be toggled through sysfs. Volatile.
</span><span>/usr/include/linux/if.h:	IFF_NOARP			= 1<&LT7,  /* sysfs */
</span><span>/usr/include/linux/if.h:#define IFF_NOARP			IFF_NOARP
</span><span>/usr/include/net/if.h:    IFF_NOARP = 0x80,		/* No address resolution protocol.  */
</span><span>/usr/include/net/if.h:# define IFF_NOARP	IFF_NOARP
</span></code></pre><h2 id=automatic-includes>Automatic includes</h2><p>Supported language servers an also automatically include the header or namespace that contains a symbol you're looking for. For example, <a href=https://github.com/clangd/clangd><code>clangd</code></a> will automatically include <code>stdio.h</code> if it sees <code>printf</code> in your file.<p>All of these workflows is something <code>nvim-cmp</code> cannot provide--it is just not designed for this.<h2 id=man-pages>Man pages</h2><p>Telescope also provides support for searching for man pages, and Neovim has first-class support for rendering man pages. This makes it a breeze to find <em>detailed</em> documentation on a topic. The information in the man pages is often dense, but <em>succinct</em>. They may also contain links to relevant pages, which Neovim can follow by default.<p>For API discoverability and documentation <em>that's available without an internet connection</em> (or even if you don't want to open up a browser), man pages are hard to beat. I love it when libraries and tools ship with man pages, but sadly, this seems like a dying practice.<h1 id=streamlining-stream-of-conciousness>Streamlining stream-of-conciousness</h1><p>One of the main goals of disabling <code>nvim-cmp</code> is to <em>optimize</em> the way I approch writing code. Instead of trying to discover an API and read its documentation <em>in-band</em> with writing code, I want to separate the two. I want to find ways to reduce the amount of noise and distraction while writing code. I want to know the API <em>before</em> I use it, not get to know it <em>while</em> I'm using it.<p>Instead of breaking my train of thought mid-line, I should be able to plow through it knowing <em>exactly</em> what I need. How far this goes, I'm not sure. Just a single expression? Maybe. A whole line? Possibly. A single scope? That would be nice. An entire function? Sweet.<p>I may not end up removing <code>nvim-cmp</code> entirely. There are sill some use-cases that don't conflict with this thesis. For example, path completion is wonderful and doesn't conflict at all with writing code.<p>I'm on the fence about snippets. Usually, when you need a snippet, you know exactly what you're getting. The <code>std</code> snippet for Zig converts <code>std</code> to <code>const std = @import("std");</code>. It's hard to make an argument that this is not a boost in efficiency.<h1 id=closing-thoughts>Closing thoughts</h1><p>In general, I see much more productivity when I can turn on some music, put my head down, and go goblin-mode for as long as I can manage before being interrupted by encountering an obstacle, such as needing to find just the right function. If I can separate reading documentation from writing code, I should be able to sustain these bouts for much longer, resulting in more productivity, better large-scale thought cohesion, and, honestly, a more enjoyable experience. After all, writing code should be <em>fun</em>, and reading documentation just takes the fun right out of it.<hr><div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>Lots of ballpark, anectdotal, pulling-it-out-my-you-know-what numbers here.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>There are some notable exceptions here, such as C#.</div></section></article></main></div>