<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Windows service programs with Zig
        
    </title><meta content="Windows service programs with Zig" property=og:title><link href=https://www.weskoerber.com/fonts.css rel=stylesheet><script async data-goatcounter=https://weskoerber.goatcounter.com/count src=https://www.weskoerber.com/js/count.js></script><noscript><img src="https://weskoerber.goatcounter.com//count?p=/posts/blog/zig-windows-service/&t=Windows service programs with Zig"></noscript><script src=https://www.weskoerber.com/js/toc.js></script><link title="Wes Koerber" href=https://www.weskoerber.com/atom.xml rel=alternate type=application/atom+xml><link href=https://www.weskoerber.com/theme/light.css rel=stylesheet><link href=https://www.weskoerber.com/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://www.weskoerber.com/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://www.weskoerber.com/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://www.weskoerber.com>Wes Koerber</a><div class=socials><a class=social href=https://github.com/weskoerber rel=me> <img alt=github src=https://www.weskoerber.com/social_icons/github.svg> </a><a class=social href=https://gitlab.com/weskoerber rel=me> <img alt=gitlab src=https://www.weskoerber.com/social_icons/gitlab.svg> </a><a class=social href=https://www.linkedin.com/in/weskoerber/ rel=me> <img alt=linkedin src=https://www.weskoerber.com/social_icons/linkedin.svg> </a><a class=social href=mailto:wes@weskoerber.com rel=me> <img alt=email src=https://www.weskoerber.com/social_icons/email.svg> </a><a class=social href=https://www.weskoerber.com/atom.xml rel=me> <img alt=rss src=https://www.weskoerber.com/social_icons/rss.svg> </a></div></div><nav><a href=https://www.weskoerber.com/posts style=margin-left:.5em>/posts</a><a href=https://www.weskoerber.com/about style=margin-left:.5em>/about</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://www.weskoerber.com/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://www.weskoerber.com/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Windows service programs with Zig<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-09-25</time></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#introduction>Introduction</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#windows-apis>Windows APIs</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#main-zig-skeleton>main.zig Skeleton</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#connect-to-the-service-control-manager>Connect to the service control manager</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#initialize-the-service>Initialize the service</a> <ul><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#passing-data-between-functions>Passing data between functions</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#registering-the-control-handler>Registering the control handler</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#thread-synchronization>Thread synchronization</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#up-and-running>Up and running</a></ul><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#handling-events>Handling events</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#wrap-up>Wrap up</a><li><a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#full-example>Full example</a></ul></div><section class=body><h1 id=introduction>Introduction</h1><p>This post will demonstrate a basic <a href=https://learn.microsoft.com/en-us/windows/win32/services/services>Windows service</a> implementation using Zig.<h1 id=windows-apis>Windows APIs</h1><p>In order to get access to the Windows APIs, we need to tell our application about the functions. To do this we can declare <code>extern</code> functions. For example, the <a href=https://learn.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-getadaptersaddresses><code>GetAdaptersAddresses</code></a> function.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>extern fn </span><span style=color:#8ec07c>GetAdaptersAddresses</span><span>(</span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>, </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>IP_ADAPTER_ADDRESSES</span><span>, </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>u32</span><span>) </span><span style=color:#fa5c4b>callconv </span><span>(</span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"std"</span><span>).os.windows.WINAPI) u32;
</span></code></pre><p>Not so bad, right?<p>Oops I almost forgot: <a href=https://learn.microsoft.com/en-us/windows/win32/api/iptypes/ns-iptypes-ip_adapter_addresses_lh><code>IP_ADAPTER_ADDRESSES</code></a> isn't defined yet. Let's add this real quick... Ok, maybe not - that's a lot of fields and a lot of typing.<p>Thankfully, <a href=https://github.com/marler8997>Jonathan Marler</a> created a binding generator appropriately named <a href=https://github.com/marlersoft/zigwin32>zigwin32</a> that generates Zig bindings for Win32. We can fetch zigwin32 with Zig's built-in package manager and make it available to our <code>build.zig</code> script.<pre class=language-shell data-lang=shell style=color:#fdf4c1aa;background-color:#282828><code class=language-shell data-lang=shell><span>zig fetch --save 'git+https://github.com/marlersoft/zigwin32#main'
</span></code></pre><p>After adding it to our <code>exe</code>'s <code>root_module</code>, we can continue.<h1 id=main-zig-skeleton><code>main.zig</code> Skeleton</h1><p>For a starting point, we'll create three functions: <code>main</code>, <code>serviceMain</code>, and <code>serviceControl</code>.<p>Our <code>main</code> function is our entry point to our application. No surprises here. The <code>serviceMain</code> and <code>serviceControl</code> functions will be called by the service control manager. We'll get into the details of these functions a bit later, but take note of their signatures and calling conventions.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceControl</span><span>(
</span><span>    </span><span style=color:#fdf4c1>code</span><span>: </span><span style=color:#fa5c4b>u32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>event_type</span><span>: </span><span style=color:#fa5c4b>u32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>event_data</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>,
</span><span>    </span><span style=color:#fdf4c1>context</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>,
</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>u32 </span><span>{
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>const</span><span> std </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"std"</span><span>);
</span><span style=color:#fa5c4b>const</span><span> win32 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"win32"</span><span>);
</span></code></pre><h1 id=connect-to-the-service-control-manager>Connect to the service control manager</h1><p>Our service program may run several different services within one process. We can define the services that run within our process as a <a href=https://learn.microsoft.com/en-us/windows/win32/api/winsvc/ns-winsvc-service_table_entrya>service table</a>. Each entry in this table contains a string holding the service name and a function pointer that points to the service's entry point. In this case, it's our <code>serviceMain</code> function. Let's define the service table in our main function.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>const</span><span> service_name </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"My Awesome Service"</span><span>;
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const</span><span> service_table </span><span style=color:#fe8019>=</span><span> [</span><span style=color:#d3869b>_</span><span>]</span><span style=color:#fa5c4b>win32.system.services.SERVICE_TABLE_ENTRYA</span><span>{
</span><span>        .{
</span><span>            .lpServiceName </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@constCast</span><span>(service_name.ptr),
</span><span>            .lpServiceProc </span><span style=color:#fe8019>=</span><span> serviceMain,
</span><span>        },
</span><span>        .{ .lpServiceName </span><span style=color:#fe8019>= </span><span style=color:#d3869b>null</span><span>, .lpServiceProc </span><span style=color:#fe8019>= </span><span style=color:#d3869b>null </span><span>},
</span><span>    };
</span><span>}
</span></code></pre><p>After we define the services our process will run, we need to connect our service program to the service control manager and tell it about our services. We do this by calling <a href=https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-startservicectrldispatchera><code>StartServiceCtrlDispatcherA</code></a>, passing the table we created in the previous step.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>StartServiceCtrlDispatcherA</span><span>(</span><span style=color:#fe8019>&</span><span>service_table[</span><span style=color:#d3869b>0</span><span>]) </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>    }
</span><span>}
</span></code></pre><p>Note that the call to <code>StartServiceCtrlDispatcherA</code> doesn't return until all services within our service table are stopped, so we can just return after this call. It is possible this function doesn't return for a very long time!<h1 id=initialize-the-service>Initialize the service</h1><p>After calling <code>StartServiceCtrlDispatcherA</code> and creating the connection, the service control manager will call our <code>serviceMain</code> function we registered in the table earlier.<p>Once we enter <code>serviceMain</code>, the service control manager needs to send events to our service. For example, in the services console in Windows, right-clicking a service displays a menu with some actions: Start, Stop, Pause, Restart, etc. These are all events that our service needs to handle. But before we handle anything, we need to tell the service control manager where to send its events. This is where the <code>serviceControl</code> function comes in.<h2 id=passing-data-between-functions>Passing data between functions</h2><p>Since <code>serviceMain</code> doesn't directly call <code>serviceControl</code>, we need some way of sharing data between these two functions. One way is to create global variables that the two functions can access. However, I really don't like global data, and try avoid it as much as possible.<p>You'll note that in the following section I choose to register our <code>serviceControl</code> function via <code>RegisterServiceCtrlHandlerExA</code> instead of <code>RegisterServiceCtrlHandlerA</code>. This is intentional. The former allows us to pass in a pointer that gets forwarded to <code>serviceMain</code>.<p>Let's create a simple <code>ServiceData</code> struct that we can provide to the control registration.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>ServiceData </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>struct </span><span>{
</span><span>    </span><span style=color:#fdf4c1>handle</span><span>: </span><span style=color:#fa5c4b>isize </span><span style=color:#fe8019>= </span><span style=color:#d3869b>-1</span><span>,
</span><span>    </span><span style=color:#fdf4c1>status</span><span>: </span><span style=color:#fa5c4b>win32.system.services.SERVICE_STATUS </span><span style=color:#fe8019>=</span><span> .{
</span><span>        .dwServiceType </span><span style=color:#fe8019>=</span><span> win32.system.services.SERVICE_WIN32_OWN_PROCESS,
</span><span>        .dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .START_PENDING</span><span>,
</span><span>        .dwControlsAccepted </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwWin32ExitCode </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwServiceSpecificExitCode </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwCheckPoint </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwWaitHint </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>    },
</span><span>    </span><span style=color:#fdf4c1>stop_event</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque </span><span style=color:#fe8019>= </span><span style=color:#d3869b>null</span><span>,
</span><span>};
</span></code></pre><p>Don't worry too much about these fields for now, we'll get to them later.<h2 id=registering-the-control-handler>Registering the control handler</h2><p>Inside our <code>serviceMain</code> function we'll register the <code>serviceControl</code> function with the service control manager, telling it to call this function when an event is generated. We do this with the <a href=https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-registerservicectrlhandlerexa><code>RegisterServiceCtrlHandlerExA</code></a> function. We'll also pass the address of a default <code>ServiceData</code> struct.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const</span><span> service_data </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>ServiceData</span><span>{};
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> status_handle </span><span style=color:#fe8019>=</span><span> win32.system.services.</span><span style=color:#fdf4c1>RegisterServiceCtrlHandlerExA</span><span>(service_name.ptr, serviceControl, </span><span style=color:#fe8019>&</span><span>service_data);
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(status_handle </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>        </span><span style=color:#fa5c4b>return</span><span>;
</span><span>    }
</span><span>}
</span></code></pre><p>This call returns a handle that we'll also need in <code>serviceControl</code>, so let's save the handle to the <code>status_handle</code> variable.<h2 id=thread-synchronization>Thread synchronization</h2><p>I hope I didn't scare you too badly with that section title, it's not that bad, I promise.<p>Our process needs to stay open as long as our services are running. If we return from <code>serviceMain</code>, our process closes and we lose our services. This is not what we want. You might be tempted to put a <code>while (true) {}</code> block at the end of <code>serviceMain</code> but that has its own problems I won't get into here.<p>Instead, we'll create a waitable event using with <a href=https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-createeventa><code>CreateEventA</code></a>. This function will create a synchronization primitive that we can use as a signaling mechanism to block the main thread until something happens. For now, let's save this event object to the <code>stop_event</code> variable.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> stop_event </span><span style=color:#fe8019>=</span><span> win32.system.threading.</span><span style=color:#fdf4c1>CreateEventA</span><span>(</span><span style=color:#d3869b>null</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>1</span><span>, </span><span style=color:#d3869b>null</span><span>);
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(stop_event </span><span style=color:#fe8019>== </span><span style=color:#d3869b>null</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>        </span><span style=color:#fa5c4b>return</span><span>;
</span><span>    }
</span><span>}
</span></code></pre><h2 id=up-and-running>Up and running</h2><p>We now have everything we need to tell the service control manager we're running and ready to handle events. Let's make sure we assign the <code>status_handle</code> and <code>stop_event</code> we created in the previous steps to our <code>ServiceData</code> struct.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    service_data.handle </span><span style=color:#fe8019>=</span><span> status_handle;
</span><span>    service_data.stop_event </span><span style=color:#fe8019>=</span><span> stop_event;
</span><span>}
</span></code></pre><p>Next, let's set our <code>ServiceData</code> state to running and tell the service control manager we'll handle stop and shutdown commands. We'll do this by updating the <code>dwCurrentState</code> and <code>dwControlsAccepted</code> fields in the <code>ServiceData.status</code> we just initialized. Then, we'll update the service control manager with this new data with the <a href=https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-setservicestatus><code>SetServiceStatus</code></a> function.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    service_data.status.dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .RUNNING</span><span>;
</span><span>    service_data.status.dwControlsAccepted </span><span style=color:#fe8019>=</span><span> win32.system.services.SERVICE_CONTROL_STOP </span><span style=color:#fe8019>|</span><span> win32.system.services.SERVICE_CONTROL_SHUTDOWN;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>SetServiceStatus</span><span>(service_data.handle, </span><span style=color:#fe8019>&</span><span>service_data.status) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>    }
</span><span>}
</span></code></pre><p>Finally, we'll await a signal from the <code>stop_event</code> we created earlier to block the process using <a href=https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject><code>WaitForSingleObject</code></a>. Since this call is blocks until we signal the <code>stop_event</code> object, we can assume if we get past this our service was stopped and we can update our status with the service control manager.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.threading.</span><span style=color:#fdf4c1>WaitForSingleObject</span><span>(service_data.stop_event, win32.system.windows_programming.INFINITE) </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>        </span><span style=color:#fa5c4b>return</span><span>;
</span><span>    }
</span><span>
</span><span>    service_data.status.dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .STOPPED</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>SetServiceStatus</span><span>(service_data.handle, </span><span style=color:#fe8019>&</span><span>service_data.status) </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>    }
</span></code></pre><h1 id=handling-events>Handling events</h1><p>Now that we've initialized our service and are blocking the process waiting for events, we can get implement the <code>serviceControl</code> function that handles these events.<p>We can retrieve our <code>service_data</code> pointer we passed previously by casting it to our <code>ServiceData</code> type. Also, we'll switch on the <code>code</code>, which is the event sent to us by the service control manager. Our service is pretty dumb, so we won't have a lot of robust handling here. For now, we'll just return <code>NO_ERROR</code>.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceControl</span><span>(
</span><span>    </span><span style=color:#fdf4c1>code</span><span>: </span><span style=color:#fa5c4b>u32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>event_type</span><span>: </span><span style=color:#fa5c4b>u32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>event_data</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>,
</span><span>    </span><span style=color:#fdf4c1>context</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>,
</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>u32 </span><span>{
</span><span>    </span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>service_data</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>ServiceData </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@alignCast</span><span>(</span><span style=color:#fabd2f>@ptrCast</span><span>(context</span><span style=color:#fe8019>.?</span><span>));
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>err</span><span>: </span><span style=color:#fa5c4b>win32.foundation.WIN32_ERROR </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>switch </span><span>(code) {
</span><span>        </span><span style=color:#fa5c4b>else </span><span style=color:#fe8019>=></span><span style=color:#d3869b> .NO_ERROR</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fabd2f>@intFromEnum</span><span>(err);
</span><span>}
</span></code></pre><p>The <a href=https://learn.microsoft.com/en-us/windows/win32/api/winsvc/nc-winsvc-lphandler_function_ex>control handler documentation</a> says that we should return <code>ERROR_CALL_NOT_IMPLEMENTED</code> if we don't handle an event, and <code>NO_ERROR</code> for the <code>SERVICE_CONTROL_INTERROGATE</code>, event if we don't handle it.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>err</span><span>: </span><span style=color:#fa5c4b>win32.foundation.WIN32_ERROR </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>switch </span><span>(code) {
</span><span>        win32.system.services.SERVICE_CONTROL_INTERROGATE </span><span style=color:#fe8019>=></span><span style=color:#d3869b> .NO_ERROR</span><span>,
</span><span>        </span><span style=color:#fa5c4b>else </span><span style=color:#fe8019>=></span><span style=color:#d3869b> .ERROR_CALL_NOT_IMPLEMENTED</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span></code></pre><p>Next, we'll handle the stop and shutdown events. When we handle these, we'll need to make sure deinitialization happens properly either here in our control handler or <code>serviceMain</code>. Remember, in the <a href=https://www.weskoerber.com/posts/blog/zig-windows-service/#up-and-running>Up and running</a> section we created and awaited our stop event which is blocking our process. If we never signaled the object, the process would never terminate. In order to signal the event object, we'll use the <a href=https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-setevent><code>SetEvent</code></a> function.<pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>err</span><span>: </span><span style=color:#fa5c4b>win32.foundation.WIN32_ERROR </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>switch </span><span>(code) {
</span><span>        win32.system.services.SERVICE_CONTROL_STOP, win32.system.services.SERVICE_CONTROL_SHUTDOWN </span><span style=color:#fe8019>=> </span><span style=color:#8ec07c>blk</span><span>: {
</span><span>            service_data.status.dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .STOP_PENDING</span><span>;
</span><span>            </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>SetServiceStatus</span><span>(service_data.handle, </span><span style=color:#fe8019>&</span><span>service_data.status) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>                </span><span style=color:#928374;font-style:italic>// error
</span><span>            }
</span><span>            </span><span style=color:#fa5c4b>if </span><span>(win32.system.threading.</span><span style=color:#fdf4c1>SetEvent</span><span>(service_data.stop_event) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>                </span><span style=color:#928374;font-style:italic>// error
</span><span>            }
</span><span>            </span><span style=color:#fa5c4b>break</span><span> :</span><span style=color:#8ec07c>blk</span><span style=color:#d3869b> .NO_ERROR</span><span>;
</span><span>        },
</span><span>
</span><span>        </span><span style=color:#928374;font-style:italic>// -- snip --
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// -- snip --
</span></code></pre><h1 id=wrap-up>Wrap up</h1><p>I hope this post was helpful in showing how to use Zig to create Windows services. I just did the bare minimum here, but there's so much room for improvement, starting with refactoring this code to read more like idiomatic Zig code.<p>It's also nearly impossible to diagnose crashes. Logging would be a great addition as well.<p>Although our service can be started, stopped, and restarted, doesn't really do anything. That's neither practical nor useful. However, the possibilities are endless. Here are some examples:<ul><li>File monitoring<li>Data backup<li>Content synchronization<li>Web APIs<li>Notifications</ul><h1 id=full-example>Full example</h1><pre class=language-zig data-lang=zig style=color:#fdf4c1aa;background-color:#282828><code class=language-zig data-lang=zig><span style=color:#fa5c4b>const</span><span> service_name </span><span style=color:#fe8019>= </span><span style=color:#b8bb26>"My Awesome Service"</span><span>;
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>main</span><span>() </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#fa5c4b>const</span><span> service_table </span><span style=color:#fe8019>=</span><span> [</span><span style=color:#d3869b>_</span><span>]</span><span style=color:#fa5c4b>win32.system.services.SERVICE_TABLE_ENTRYA</span><span>{
</span><span>        .{
</span><span>            .lpServiceName </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@constCast</span><span>(service_name.ptr),
</span><span>            .lpServiceProc </span><span style=color:#fe8019>=</span><span> serviceMain,
</span><span>        },
</span><span>        .{ .lpServiceName </span><span style=color:#fe8019>= </span><span style=color:#d3869b>null</span><span>, .lpServiceProc </span><span style=color:#fe8019>= </span><span style=color:#d3869b>null </span><span>},
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>StartServiceCtrlDispatcherA</span><span>(</span><span style=color:#fe8019>&</span><span>service_table[</span><span style=color:#d3869b>0</span><span>]) </span><span style=color:#fe8019>> </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceMain</span><span>(</span><span style=color:#fdf4c1>argc</span><span>: </span><span style=color:#fa5c4b>u32</span><span>, </span><span style=color:#fdf4c1>argv</span><span>: </span><span style=color:#fe8019>?*?</span><span>[</span><span style=color:#fe8019>*</span><span>:</span><span style=color:#d3869b>0</span><span>]</span><span style=color:#fa5c4b>const u8</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>void </span><span>{
</span><span>    </span><span style=color:#d3869b>_ </span><span style=color:#fe8019>=</span><span> argc;
</span><span>    </span><span style=color:#d3869b>_ </span><span style=color:#fe8019>=</span><span> argv;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>var</span><span> service_data </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>ServiceData</span><span>{};
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> status_handle </span><span style=color:#fe8019>=</span><span> win32.system.services.</span><span style=color:#fdf4c1>RegisterServiceCtrlHandlerExA</span><span>(service_name.ptr, serviceControl, </span><span style=color:#fe8019>&</span><span>service_data);
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(status_handle </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>        </span><span style=color:#fa5c4b>return</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const</span><span> stop_event </span><span style=color:#fe8019>=</span><span> win32.system.threading.</span><span style=color:#fdf4c1>CreateEventA</span><span>(</span><span style=color:#d3869b>null</span><span>, </span><span style=color:#d3869b>0</span><span>, </span><span style=color:#d3869b>1</span><span>, </span><span style=color:#d3869b>null</span><span>);
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(stop_event </span><span style=color:#fe8019>== </span><span style=color:#d3869b>null</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>        </span><span style=color:#fa5c4b>return</span><span>;
</span><span>    }
</span><span>
</span><span>    service_data.handle </span><span style=color:#fe8019>=</span><span> status_handle;
</span><span>    service_data.stop_event </span><span style=color:#fe8019>=</span><span> stop_event;
</span><span>
</span><span>    service_data.status.dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .RUNNING</span><span>;
</span><span>    service_data.status.dwControlsAccepted </span><span style=color:#fe8019>=</span><span> win32.system.services.SERVICE_CONTROL_STOP </span><span style=color:#fe8019>|</span><span> win32.system.services.SERVICE_CONTROL_SHUTDOWN;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>SetServiceStatus</span><span>(service_data.handle, </span><span style=color:#fe8019>&</span><span>service_data.status) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.threading.</span><span style=color:#fdf4c1>WaitForSingleObject</span><span>(service_data.stop_event, win32.system.windows_programming.INFINITE) </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>        </span><span style=color:#fa5c4b>return</span><span>;
</span><span>    }
</span><span>
</span><span>    service_data.status.dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .STOPPED</span><span>;
</span><span>    </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>SetServiceStatus</span><span>(service_data.handle, </span><span style=color:#fe8019>&</span><span>service_data.status) </span><span style=color:#fe8019>!= </span><span style=color:#d3869b>0</span><span>) {
</span><span>        </span><span style=color:#928374;font-style:italic>// error
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>pub fn </span><span style=color:#8ec07c>serviceControl</span><span>(
</span><span>    </span><span style=color:#fdf4c1>code</span><span>: </span><span style=color:#fa5c4b>u32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>event_type</span><span>: </span><span style=color:#fa5c4b>u32</span><span>,
</span><span>    </span><span style=color:#fdf4c1>event_data</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>,
</span><span>    </span><span style=color:#fdf4c1>context</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque</span><span>,
</span><span>) </span><span style=color:#fa5c4b>callconv</span><span>(std.os.windows.WINAPI) </span><span style=color:#fa5c4b>u32 </span><span>{
</span><span>    </span><span style=color:#d3869b>_ </span><span style=color:#fe8019>=</span><span> event_type;
</span><span>    </span><span style=color:#d3869b>_ </span><span style=color:#fe8019>=</span><span> event_data;
</span><span>
</span><span>    </span><span style=color:#fa5c4b>var </span><span style=color:#fdf4c1>service_data</span><span>: </span><span style=color:#fe8019>*</span><span style=color:#fa5c4b>ServiceData </span><span style=color:#fe8019>= </span><span style=color:#fabd2f>@alignCast</span><span>(</span><span style=color:#fabd2f>@ptrCast</span><span>(context</span><span style=color:#fe8019>.?</span><span>));
</span><span>
</span><span>    </span><span style=color:#fa5c4b>const </span><span style=color:#fdf4c1>err</span><span>: </span><span style=color:#fa5c4b>win32.foundation.WIN32_ERROR </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>switch </span><span>(code) {
</span><span>        win32.system.services.SERVICE_CONTROL_STOP, win32.system.services.SERVICE_CONTROL_SHUTDOWN </span><span style=color:#fe8019>=> </span><span style=color:#8ec07c>blk</span><span>: {
</span><span>            service_data.status.dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .STOP_PENDING</span><span>;
</span><span>            </span><span style=color:#fa5c4b>if </span><span>(win32.system.services.</span><span style=color:#fdf4c1>SetServiceStatus</span><span>(service_data.handle, </span><span style=color:#fe8019>&</span><span>service_data.status) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>                </span><span style=color:#928374;font-style:italic>// error
</span><span>            }
</span><span>            </span><span style=color:#fa5c4b>if </span><span>(win32.system.threading.</span><span style=color:#fdf4c1>SetEvent</span><span>(service_data.stop_event) </span><span style=color:#fe8019>== </span><span style=color:#d3869b>0</span><span>) {
</span><span>                </span><span style=color:#928374;font-style:italic>// error
</span><span>            }
</span><span>            </span><span style=color:#fa5c4b>break</span><span> :</span><span style=color:#8ec07c>blk</span><span style=color:#d3869b> .NO_ERROR</span><span>;
</span><span>        },
</span><span>        win32.system.services.SERVICE_CONTROL_INTERROGATE </span><span style=color:#fe8019>=></span><span style=color:#d3869b> .NO_ERROR</span><span>,
</span><span>        </span><span style=color:#fa5c4b>else </span><span style=color:#fe8019>=></span><span style=color:#d3869b> .ERROR_CALL_NOT_IMPLEMENTED</span><span>,
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#fa5c4b>return </span><span style=color:#fabd2f>@intFromEnum</span><span>(err);
</span><span>}
</span><span>
</span><span style=color:#fa5c4b>const</span><span> std </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"std"</span><span>);
</span><span style=color:#fa5c4b>const</span><span> win32 </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>@import</span><span>(</span><span style=color:#b8bb26>"win32"</span><span>);
</span><span style=color:#fa5c4b>const </span><span style=color:#8ec07c>ServiceData </span><span style=color:#fe8019>= </span><span style=color:#fa5c4b>struct </span><span>{
</span><span>    </span><span style=color:#fdf4c1>handle</span><span>: </span><span style=color:#fa5c4b>isize </span><span style=color:#fe8019>= </span><span style=color:#d3869b>-1</span><span>,
</span><span>    </span><span style=color:#fdf4c1>status</span><span>: </span><span style=color:#fa5c4b>win32.system.services.SERVICE_STATUS </span><span style=color:#fe8019>=</span><span> .{
</span><span>        .dwServiceType </span><span style=color:#fe8019>=</span><span> win32.system.services.SERVICE_WIN32_OWN_PROCESS,
</span><span>        .dwCurrentState </span><span style=color:#fe8019>=</span><span style=color:#d3869b> .START_PENDING</span><span>,
</span><span>        .dwControlsAccepted </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwWin32ExitCode </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwServiceSpecificExitCode </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwCheckPoint </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>        .dwWaitHint </span><span style=color:#fe8019>= </span><span style=color:#d3869b>0</span><span>,
</span><span>    },
</span><span>    </span><span style=color:#fdf4c1>stop_event</span><span>: </span><span style=color:#fe8019>?*</span><span style=color:#fa5c4b>anyopaque </span><span style=color:#fe8019>= </span><span style=color:#d3869b>null</span><span>,
</span><span>};
</span></code></pre></section></article></main></div>